# 对 React 的看法是什么?它的优缺点是什么?使用过程中遇到的问题是如何解决的?

# 一个 dom 必须要操作几百次，改如何解决，如何优化?

# redux 请求中间件如何处理并发

# 给出页面的加载顺序

# 什么是死锁

# utf-8 和 asc 码有什么区别

# 如何创建一个 ajax

# vue的双向绑定的原理是什么？

# Loader和Plugin的区别是什么？

【Loader】：用于对模块源码的转换，loader描述了webpack如何处理非javascript模块，并且在buld中引入这些依赖。loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。

loader的使用很简单：

在webpack.config.js中指定loader。module.rules可以指定多个loader，对项目中的各个loader有个全局概览。

loader是运行在NodeJS中，可以用options对象进行配置。plugin可以为loader带来更多特性。loader可以进行压缩，打包，语言翻译等等。

loader从模板路径解析，npm install node_modules。也可以自定义loader，命名XXX-loader。

语言类的处理器loader：CoffeeScript，TypeScript，ESNext（Bable）,Sass,Less,Stylus。任何开发技术栈都可以使用webpack。

【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。

webpack功能强大，难点在于它的配置文件，webpack4默认不需要配置文件，可以通过mode选项为webpack指定了一些默认的配置，mode分为：development/production，默认是production。

插件可以携带参数，所以在plugins属性传入new实例。

# 请解释React中props和state的区别？

在React中props和state都属于组件的数据，他们的改变都可能会触发组件的重新渲染。 

- props 是组件对外的接口，对于传入的组件而言时可读的、不可变的，遵循单向数据流原则

- state 是维护组件内部状态的， 是可变的。 

组件内可以引用其他组件，组件之间的引用形成了一个树状结构，如果下层组件需要使用上层组件的数据或方法，上层组件就可以通过下层组件的props属性进行传递，因此props是组件对外的接口，用于组件间的通信。props不能通过子组件自身的方法修改，只能通过父组件传递的回调函数在父组件进行修改。 组件除了使用上层组件传递的数据外，自身也可能需要维护管理数据，这就是组件对内的接口state。修改组件内部状态需要使用setState或forceUpdate方法来改变。 根据对外接口props 和对内接口state，组件计算出对应界面的UI。 

主要区别： 
- state是可变的，是一组用于反映组件UI变化的状态集合；
- props对于使用它的组件来说，是只读的，要想修改props，只能通过该组件的父组件修改。 在组件状态提升的场景中，父组件正是通过子组件的props, 传递给子组件其所需要的状态。
- 没有state的组件叫做无状态组件，它接收props，只负责渲染，反之则叫做有状态组件。工作中应尽量使用无状态组件，增加代码的可维护性和复用性。

# 浏览器的本地存储(1)的cookie了解多少？

HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的HTTP协议记录稳定的状态信息成为了可能。 

Cookie 主要用于以下三个方面： 

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 

- 个性化设置（如用户自定义设置、主题等） 

- 浏览器行为跟踪（如跟踪分析用户行为等） 

Cookie 的生命周期可以通过两种方式定义：

- 会话期 Cookie 是最简单的 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期Cookie不需要指定过期时间（Expires）或者有效期（Max-Age）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期Cookie 也会被保留下来，就好像浏览器从来没有关闭一样，这会导致 Cookie 的生命周期无限期延长。 

- 持久性 Cookie 的生命周期取决于过期时间（Expires）或有效期（Max-Age）指定的一段时间。

# 浏览器的本地存储(2)的WebStorage了解多少？

# 说一下vue-router的原理是什么?

# 防抖节流原理、区别以及应用，请用js实现。

# 在css中link和@import的区别是什么？

首先，他们本质都是为了加载css文件。

### link
```
<link href="css 路径" rel="stylesheet" type="text/css" />
```

### @import
```
@import url(css 文件路径地址);
```

### 区别

语法结构不同，如上所示：
- link是html标签，只能放到html文档中使用
- @import是css提供的一种引入样式的方式，因此需要放在<style type="text/css">标签中
- 
用途不同：
- link标签除了加载css文件外，还可以定义RSS，定义rel链接属性登
- @import只能加载css

加载顺序不同：
- 当一个页面被加载的时候，link引用的css会同时被加载
- @import引用的css则会等到页面完全被下载完才会去加载，因此，浏览@import加载css的页面时会没有样式（闪烁）

兼容：
- @import在老浏览器中不支持

总结：推荐link方式

# 常见的loader以及作用的总结

Loader用于对模块的源代码进行转换，可以使你在 import 或 加载模块时预处理文件。由于webpack本身只能打包JavaScript文件，对于其他资源，如css、图片、JSX等是无法处理的。这时候就需要用到loader将资源转化。Loader本质上就是一个export出来的函数，接受要处理的源文件字符串，返回经过“翻译”后的webpack可以直接处理的模块。

常用loader及作用：
- raw-loader：加载文件原始内容（utf-8）
- file-loader：把文件输出到一个文件夹中，在代码中通过相对URL去引用输出的文件
- url-loader：和file-loader类似，但是能在文件很小的情况下以base64的方式把文件内容注入到代码中
- source-map-loader：加载额外的Source Map文件，以方便断点调试
- svg-inline-loader：将压缩后的 SVG 内容注入代码中
- image-loader：加载并且压缩图片文件
- json-loader：加载 JSON 文件（默认包含）
- handlebars-loader：将 Handlebars 模版编译成函数并返回
- babel-loader：把ES6转化成ES5
- ts-loader: 将 TypeScript 转换成 JavaScript
- awesome-typescript-loader：将 TypeScript 转换成 JavaScript，性能优于 ts-loader
- css-loader：加载css，支持模块化、压缩、文件导入等特性
- style-loader：把css代码注入到js中，通过DOM操作去加载css
- eslint-loader：通过ESLint检查JS代码
- tslint-loader：通过 TSLint检查 TypeScript 代码
- postcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀
- vue-loader：加载 Vue.js 单文件组件
- cache-loader: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里

# vue计算属性和普通属性的区别是什么?

# webpack中source map是什么？生产环境怎么用？

# 浏览器缓存机制(1)对于开发很重要，强缓存的内容能了解多少呢？

# 介绍js全部数据类型，基本数据类型和引用数据类型的区别

# react-router里的Link标签和a标签有什么区别？

# 说一说XSS攻击

# 谈谈你对重绘和回流的理解

# 简单说下你理解的语义化，怎样来保证你写的符合语义化？HTML5语义化标签了解下

# 常见的plugin以及作用的总结

# 说一下关于tree-shaking的原理

# 如何实现 webpack 持久化缓存

# webpack的构建流程是什么

# 说一说CSRF攻击

# CSS伪类和伪元素区别

### 什么是css伪类（CSS pseudo-classes）
伪类的概念引入是为了能够表达在文档树语法之外无法通过简单的选择器表达的信息。伪类的语法是单个冒号带一个伪类名称。不区分大小写。有的伪类是互斥的，有的可以同时作用在同一个元素上，伪类也可以是动态的，来响应用户的交互。

有哪些伪类：
- :link 默认带href属性的a标签的样式
- :visited 被访问过的链接的样式
- :hover 鼠标悬浮上去的样式
- :active 鼠标按下去的时候的样式
>（上面四种定义的时候需要保证这样的顺序）

- :focus 当前元素为focus状态
- :lang lang(en) 对应html上的lang属性，符合的话执行样式
- :empty 选择没有子元素的元素执行样式
- :enable 选择表单元素具有非disable属性的元素，执行样式
- :disable 选择表单元素具有disable属性的元素。执行样式
- :checked 单选按钮或者多选按钮被选中的，执行样式
- :target 锚点跳转到的内容执行样式
- :root 匹配文档的根元素。html中默认就是html元素
- :default 默认状态的表单元素，比如默认选中的下拉框，单选按钮，多选按钮，执行样式
- :first-of-type 选中该元素是别人首个子元素，例如p:first-of-type 就是所以元素子元素中第一个p元素
- :last-of-type 意义和上面类似，代表最后一个
- :only-of-type 代表所有元素中只有一个该类型的元素p:only-of-type
- :only-child 例如p:only-child 代表子元素中只有一个元素，且必须是该类型p
- :first-child 例如p:first-child 代表是父元素中的第一个元素，且类型为p
- :last-child 意义同上，最后一个元素
- :nth-child(n) 例如p:nth-child(2) 表示选择子元素第二个且类型为p的元素，n从1开始算
- :nth-last-child(n) 意思和上面类似，只不过是从结尾开始往前数第n个，n是从1开始算
- :nth-of-type(n) 例如p:nth-of-type(2) 代表子元素中第二次出现的p元素 n从1开始算
- :nth-last-of-type(n) 意义和上面类似，只不过是从尾部往前数，n从1开始算
- :not() 例如 :not(p) 匹配非p元素

### 什么是css伪元素（CSS pseudo-element）
伪元素是在html文档树语法的基础上创造的一种抽象概念，例如，文档树语法里并没有提供一种机制让我们访问一个元素的内容的首个字母或者首行，伪元素提供了访问这样难以访问的信息的能力，伪元素还提供了对dom节点内不存在的内容的引用和生成能力，比如::after ::before 提供了生成内容的能力。

一个伪元素包含两个冒号 ::

有哪些常用伪元素：
- ::first-letter 匹配内容的首个字符
- ::first-line 匹配内容的首行内容
- ::before 匹配内容前面的部分
- ::after 匹配紧跟内容后面的部分
- ::selection 匹配用户通过鼠标或者其他设备选中的内容部分

### 伪类和伪元素的区别

1、写法的区别

在css3中定义了双冒号代表伪元素，单冒号代表伪类。以此来区分伪元素和伪类。为了兼容老的浏览器，用单冒号类表达伪元素也是能够被识别的，比如写:after :before :first-line :fist-letter。

2、概念的区别

伪类侧重丰富选择器的选择语法范围内元素的选择能力，伪元素侧重表达或者定义不在语法定义范围内的抽象元素。

3、兼容性

伪类和伪元素各自有一些存在的兼容问题。

# Vuex和localStorage的区别

# 说一下事件循环机制(node 浏览器)

# webpack的构建流程是什么

# Import和CommonJs在webpack打包过程中有什么不同

# dev-server是怎么跑起来的

# 谈谈关于对webpack热更新的原理

# 浏览器缓存机制(3)对于开发很重要，缓存位置的内容能了解多少呢

# webpack打包时Hash码是怎样生成的？随机值存在一样的情况，如何避免？

# 如何加快页面渲染速度，都有哪些方式？(js方面)

# HTTP请求特征是什么

# react里组件通信有几种方式，分别怎样进行通信

# 说一下栈和堆的区别，垃圾回收时栈和堆的区别

# 布局都有什么方式，float和position有什么区别

# 用JS代码实现事件代理

# 对虚拟DOM的理解？虚拟DOM主要做了什么？虚拟DOM本身是什么？

# 移动端需要注意什么

# 响应式布局用到的技术有几种方式

# 词法作用域和this的区别

# 介绍React高阶组件，适用于什么场景？

# 说一下Vue的keep-alive是如何实现的，具体缓存的是什么

# 请描述下css盒模型基本概念

# React组件中怎么做事件代理？它的原理是什么？

# Promise 构造函数是同步还是异步执行，then呢？

# 说一下mobx和redux有什么区别

# CSS预处理器的概念

# shouldComponentUpdate是为了解决什么问题

# React里setState到底是异步还是同步

# react-redux的工作流程是什么

# 添加原生事件不移除为什么会内存泄漏，还有哪些地方会存在内存泄漏？（js）

# 怎么处理项目中的异常捕获行为

# 点击一个按钮，浏览器会做些什么事情【呈现效果时流程】

# 解决异步的问题的几种方式？Promise解决了异步问题吗？

# 与HTTP相关的协议有哪些？TCP/IP DNS URI/URL HTTPS

# CDN有哪些优化静态资源加载速度的机制

# 说说你理解的node 中间层怎样做的请求合并转发

# webpack做了什么？使用webpack构建是否有做一些自定义操作

# webpack如何用localStorage离线缓存静态资源

# 关于对 Vue 项目进行优化有哪些？

# 说一下React.Component和React.PureComponent的区别

# 使用import时，webpack对node_modules里的依赖会做什么

# Redux和Vuex有什么区别,说一下它们的共同思想

# 为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象

# 说一下mysql和mongodb的区别

# 说一下你对React context的理解

# webpack 里面的插件是如何实现的

# 使用TS的优势有哪些

# 直接给一个数组项赋值，Vue 能检测到变化吗

# Vue 组件间通信有哪几种方式

# 项目如何管理模块

# 在哪个生命周期内调用异步请求

# 说明一下JS封装的原理

# 说出常用的页面优化实现方案

# 回调函数和任务队列的区别

# 请你谈谈对无状态的理解 (React)

# 如何理解事件委托

# BFC是什么？触发BFC的条件是什么？有哪些应用场景

# 说一下单向数流有什么好处

# React怎么做数据检查和变化

# 类数组转化为数组

# 说一下关于tree-shaking的原理

# Vue 中的 key 有什么作用

# 说一下Vue 的父组件和子组件生命周期钩子函数执行顺序

# 使用过 Vue SSR 吗？说说 SSR

# 什么情况下出现浏览器分层？(css部分)

# 说下JS继承的原理

# 说一下Vue的$nextTick原理

# 说一下Vue单页与多页的区别

# v-model是如何实现的，语法糖实际是什么

# 怎样理解 Vue 的单向数据流

# React SSR实现过程

# React SSR实现原理是什么,需要注意什么事项

# 子组件可以直接改变父组件的数据么？说说你的理由？(vue)

# 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗

# 实现数组去重

# 描述下JS中Prototype的概念

# 实现数组扁平化

# React事件绑定原理是什么

# 为什么不建议使用通配符初始化css样式

# 说一下koa2和express区别

# link 标签定义

# 渲染过程中遇到JS文件怎么处理?(浏览器解析过程)

# Object.is()与原来的比较操作符 "===" 、"==" 的区别

使用双等号进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较

使用三等号进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false

使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 认定为是相等的。

# 三种事件模型是什么

1、DOM0级事件模型（原始事件模型）

通过属性绑定，如 onclick="xxxx()"，或者通过获取到元素后，以赋值的形式绑定事件

2、DOM2级事件模型

新增了捕获和冒泡机制，并支持同一个元素绑定多个事件。

DOM2 级事件模型共有三个阶段：

事件捕获阶段：事件从 document 向下传播到目标元素，依次检查所有节点是否绑定了监听事件，如果有则执行。

事件处理阶段：事件在达到目标元素时，触发监听事件。

事件冒泡阶段：事件从目标元素冒泡到 document，并且一次检查各个节点是否绑定了监听函数，如果有则执行。

3、IE事件模型

IE事件只支持冒泡，所以事件流有两个阶段：

事件处理阶段：事件在达到目标元素时，触发监听事件。

事件冒泡阶段：事件从目标元素冒泡到 document，并且一次检查各个节点是否绑定了监听函数，如果有则执行。


# DOCTYPE 的作用是什么

# iframe有哪些缺点

# 说说你对浏览器的理解

# 谈谈你对ajax的理解

# 简单介绍使用图片base64编码的优点和缺点

# 请说出目前主流的js模块化实现的技术有哪些?他们的区别在哪儿

# for..in和Object.keys的区别
for..in
- 遍历对象上及其原型链上可枚举的属性
- 如果用于遍历数组，除了遍历其元素外，还会遍历开发者对数组对象自定义的可枚举属性及其原型链上的可枚举属性（不推荐for...in遍历数组)
- 遍历对象返回的属性名和遍历数组返回的索引都是字符串类型
- 某些情况下，可能按随机顺序遍历数组元素

Object.keys
- 返回对象自身可枚举属性组成的数组
- 不会遍历对象原型链上的属性以及Symbol属性
- 对数组的遍历循序和for..in一致

for of
- es6中添加的循环遍历语法
- 支持遍历数组，类数组对象(DOM NodeList)，字符串，Map对象，Set对象
- 不支持遍历普通对象
- 遍历后输出的结果为数组元素的值
- 可搭配实例方法entries(),同时输出数组的内容和索引

# 哪些操作会造成内存泄漏

# 什么是浏览器的同源策略

# 说一下你理解margin重叠的问题

# 网页验证码是干嘛的，是为了解决什么安全问题

# display、position和float的相互关系

# 前端需要注意哪些SEO

SEO具体是指通过网站结构调整、网站内容建设、网站代码优化、以及站外优化（网站站外推广、网站品牌建设等），使网站满足搜索引擎的收录排名需求，提高网站在搜索引擎中关键字的排名，从而吸引精准用户进入网站，获得免费流量，产生直接销售或品牌推广。

需要注意：

1、 合理的title，description，keyswords 搜索引擎对这三项的权重逐个减小，title 值强调重点即可，重要的关键

词出现不要超过两次，而且要靠前。

2 、不同页面的tilte要有所不同；description把页面的内容高度概括，长度合适，不可过分堆叠关键词，不同页面

description有所不同。keyswords列举出重要的关键词即可。

3、语义化的HTML代码，符合W3C 规范：语义化代码有利于搜索引擎理解网页。

4 、重要的内容HTML代码放在前面：搜索引擎抓取HTML 的顺序是从上到下，有的搜索引擎对抓取长度有限制，保

证重要内容一定会被抓取。

5 、重要的内容不要用js输出，爬虫不会执行js获取内容。

6 、尽量少用iframe ，搜索引擎不会抓取iframe中的内容。

7 、非装饰的图片必须加alt 。

8 、提高网站速度：网站速度是搜索引擎排序的一个重要指标。

# 简单说一下V8引擎的垃圾回收机制

# 谈谈对JSON的理解

# 渲染页面时常见的不良现象有哪些?(浏览器渲染过程)
白屏、闪烁

# html布局元素的分类有哪些? 描述下每种布局元素的应用场景

# componentWillReceiveProps的触发条件是什么

# javascript 代码中的"use strict"是什么意思?为什么使用它 

# javascript 代码中的"use strict"是什么意思?为什么使用它

# 什么是 polyfill

# 说一下Vue的生命周期以及每个阶段做的事情
1.beforeCreate(创建前) 在数据观测和初始化事件还没有开始

2.created(创建后) 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来

3.beforeMounted(挂载前) 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成下面的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上

4.mounted(挂载后) 在el被新创建的vm.$el替换，并挂载到实例上去之后调用。实例已经完成下面的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中，此过程中可进行ajax交互

5.beforeUpdate(更新前) 在数据更新之前调用，发生在虚拟dom重新渲染和打补丁之前。可以在该钩子中进一步更改状态，不会触发重复渲染过程

6.update(更新后) 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件dom已经更新，所以可以执行依赖于dom操作。但是在大多数情况下，在此期间避免更改状态，因为这可能会导致更新无法循环。此钩子在服务端渲染期间不被调用

7.beforeDestroy(销毁前) 在实例销毁之前调用。实例仍然完全可以用。

8.destroyed(销毁后) 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。此钩子在服务端渲染期间不被调用

# 你所理解的同步和异步的区别是什么

# javascript 创建对象的几种方式

# 说一下你所理解JavaScript中的作用域与变量声明提升

# 内部属性[[Class]]是什么

# 检测浏览器版本版本有哪些方式

# React 高阶组件、Render props和hooks有什么区别,为什么不断迭代

# 说一下Vue template到render的过程

# 如何解决跨域问题

- 将 document.domain 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe的话，我们也可以对这个 iframe 进行操作。如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的iframe 进行通信的问题，我们可以使用 location.hash 或者 window.name 或者postMessage 来解决问题

- 使用 location.hash 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。

- 使用 window.name 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，这种方式的好处是可以传输的数据量大。

- 使用 postMessage 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。

- 使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script 标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get请求。

- 使用 CORS 的方式，CORS 是一个 W3C 标准，全称是"跨域资源共享"。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。

- 使用 websocket 协议，这个协议没有同源限制。

- 使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。

# margin和padding分别适合什么场景使用

# CSS多列等高如何实现

# 如何处理HTML5新标签的浏览器兼容问题

# 介绍一下你对浏览器内核的理解

# 扫描二维码登录网页是什么原理，前后两个事件是如何联系的

# 说一下你所理解的渲染原理

- 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。

- 然后对 CSS 进行解析，生成 CSSOM 规则树。

- 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。

- 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。

- 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。

# 如何判断一个对象是否属于某个类

- 第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置

- 第二种方式可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写

- 第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用Object.prototype.toString.call() 方法来打印对象的[[Class]] 属性来进行判断

# 什么是DOM和BOM

# CSS选择符有哪些
id 选择器（#myid）

类选择器（.myclassname）

标签选择器（div,h1,p）

后代选择器（h1 p）

相邻后代选择器（子）选择器（ul>li）

兄弟选择器（li~a）

相邻兄弟选择器（li+a）

属性选择器（a[rel="external"]）

伪类选择器（a:hover,li:nth-child）

伪元素选择器（::before、::after）

通配符选择器（*）

# 标准模式与兼容模式各有什么区别

# css如何影响文档解析

css加载不会阻塞DOM树的解析, 但会阻塞DOM树的渲染，也会阻塞后面js语句的执行。 因此，为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度，比如可以使用以下几种方法:

1、使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)

2、对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)

3、合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)

4、减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)

# 说一下你所了解的javascript的作用域链

# DOMContentLoaded事件和Load事件的区别

# Symbol 值的强制类型转换

# HTML5有哪些新特性、移除了哪些元素

HTML5新特性：

拖放（Drag and drop）API

语义化标签（header、nav、footer、section、article、aside）

音频、视频（audio、video）API

画布（canvas）API

地理定位（Geolocation）API

本地离线存储（localStorage），即长期存储数据，浏览器关闭后数据不丢失；会话存储（sessionStorage），即数据在浏览器关闭后自动删除

表单控件（calender、date、time、url、email、search）

新的技术（webworker、websocket）

新的文档属性 document.visibilityState


移除的元素：

纯表现的元素：basefont、big、center、font、s、strike、tt、u

对可用性产生负面影响的元素：frame、frameset、noframes

# 说一下对DTD的理解

DTD（ Document Type Definition 文档类型定义）是一组机器可读的规则，它们定义 XML或 HTML 的特定版本中所有允许元素及它们的属性和层次关系的定义。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。

DTD 是对 HTML 文档的声明，还会影响浏览器的渲染模式（工作模式）。主要用来解决传输问题，它的存在可以使我们能够使用某个标准的DTD来 交换数据、检验数据。

# 常见浏览器所用的内核

- IE 浏览器内核：Trident 内核，也是俗称的 IE 内核

- Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit内核，现在是 Blink 内核

- Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核

- Safari 浏览器内核：Webkit 内核

- Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit又到了 Blink 内核

- 360 浏览器、猎豹浏览器内核：IE + Chrome 双内核

- 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）

- 百度浏览器、世界之窗内核：IE 内核

- 2345 浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了

- UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核

# 什么是文档的预解析

# js继承的几种实现方式

# React key是干什么用的,为什么要加上key

key是React用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识

在开发过程中，我们需要保证某个元素的key在其同级元素中具有唯一性

在React Diff算法中React会借助元素的key值来判断该元素是新创建的还是被移动而来的元素，从而减少不必要的元素重新渲染

此外，React还需要借助Key值来判断元素与状态的关联关系

几点注意事项:
- key值一定要和具体的元素一一对应
- 尽量不要使用数组的index去作为key值
- 永远不要试图在render的时候用随机数或者其他操作给元素加上不稳定的key，这样会造成的性能开销比不加key的情况下要糟糕

# 说一下你理解的 HTTPS 中间人攻击

HTPPS 协议由 HTTP + SSL 协议构成

中间人攻击过程如下：

- 服务器向客户端发送公钥

- 攻击者截获公钥，保留在自己手上

- 然后攻击者自己生成一个【伪造的】公钥，发给客户端

- 客户端收到伪造的公钥后，生成加密 hash（秘钥） 值发给服务器

- 攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥

- 同时生成假的加密 hash 值，发给服务器

- 服务器用私钥解密获得假秘钥

- 服务器用假秘钥加密传输信息

防范方法：

服务器在发送浏览器的公钥中加入 CA 证书，浏览器可以验证 CA 证书的有效性；（现有 HTTPS 很难被劫持，除非信任了劫持者的 CA 证书）。

# 说一下你所理解的观察者模式

# SGML、HTML、XML和XHTML的区别

SGML 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源

HTML 是超文本标记语言，主要是用于规定怎么显示网页

XML 是可扩展标记语言是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于XML 的标签是可以自己创建的，数量无限多，而 HTML 的标签都是固定的而且数量有限

XHTML 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML 更严格，比如标签必须都用小写，标签都必须有闭合标签等

# 说一下你所了解的react-fiber

fiber实现了自己的组件调用栈，它以链表的形式遍历组件树，可以灵活的暂停、继续和丢弃执行的任务。实现方式是使用了浏览器的requestldeCallback这一个api。fiber其实值得是一种数据结构，它可以用一个纯js对象来进行表示。

react内部运转分三层：

- Virtual DOM层：描述页面长什么样子
- Reconciler层:负责调用组件声明周期方法，进行Diff运算等
- Renderer层:根据不同的平台，渲染出相应的页面，常见的是react-dom

为了实现不卡顿的效果，需要有一个调度器(Scheduler)来进行分配。优先级高的任务(键盘输入)可以打断优先级低的任务(diff)的执行，从而更快的生效。任务的优先级有六种：

- synchronous，与之前的Stack Reconciler操作一样，同步执行
- task，在next tick之前执行
- animation，下一帧之前执行
- high，在不久的将来执行
- low，稍微延迟执行也没关系
- offscreen，下一次render时或scroll时才执行

Fiber Reconclier(react)执行阶段:

- 阶段1：生成一个Fiber树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断
- 阶段2：将需要更新的节点一次批量更新，这个过程不能被打断。

Fiber树：Fiber Reconciler在阶段1进行diff计算的时候，会基于virtual DOM树生成一颗Fiber树，它的本质是链表。

# 异步编程的实现方式是什么

1、回调函数

优点：简单、容易理解 缺点：不利于维护，代码耦合高，多个异步操作下容易形成回调地狱。

2、Promise

优点：可以利用then方法，进行链式写法；可以书写错误时的回调函数； 缺点：编写和理解，相对比较难，语义不是那么明确

3、Generation

优点：函数体内外的数据交换、错误处理机制 缺点：流程管理不方便，控制权的转换需要特别注意

4、async/await

优点：内置执行器、更好的语义、更广的适用性、返回的是Promise、结构清晰。 缺点：错误处理机制， 需要try-catch捕获

# 什么是函数柯里化

把接收多个参数的函数变换为接收一个单一参数（最初函数的第一个参数）的函数，并返回接收剩余参数而且返回结果的新函数的技术。

优点：

- 可以延迟计算，即如果调用柯里化函数传入参数是不调用的，会将参数添加到数组中存储，等到没有参数传入的时候进行调用

- 参数复用，当在多次调用同一个函数，并且传递的参数绝大多数是相同的，那么该函数可能是一个很好的柯里化函数

# 说一下import的原理，和require的不同之处

import原理(实际上就是ES6 module的原理)：简单来说就是闭包作用。

为了创建Module的内部作用域，会调用一个包装函数

包装函数的返回值也就是Module向外公开的API，也就是所有export出去的变量

import是拿到module导出变量的引用

与require的不同之处：

CommonJS模块输出的是一个值的拷贝，ES6模块输出的值的引用

CommonJS模块是运行时加载，ES6模块是编译时输出接口

CommonJS是运行时加载对应模块，一旦输出一个值，即使模块内部对其做出改变，也不影响输出值。而ES6模块不同，import导入是在JS引擎对脚步静态分析时确定，获取到的是一个只读引用。等脚本引擎运行时，会根据这个引用去对应模块中的取值，所以引用对应的值改变的时候，其导入的值也会发生改变

# 使用 Object.defineProperty() 来进行数据劫持有什么缺点

1、无法检测到对象属性的新增或删除

2、无法监听数组变化

替代方案： ES6 Proxy

# 面向对象的三要素是什么，分别是什么意思

封装: 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏

继承: 使用现有类的所有功能并在无需重新编写原来的类的情况下对这些功能进行扩展

多态: 一个类实例的相同方法在不同情形下有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口

# 说一下base64的编码方式

Base64是一种编码方式。选用大小写字母、数字0-9、+和/的64个可打印字符来表示二进制数据。将二进制数据每三个字节为一组。一共是3 * 8=24bit(位)，划分为四组，每一组为6bit(位)。如果要编码的二进制不是3的倍数，会用00在末尾补足，然后在编码的末尾加上1-2个=号，表示补了多少字节，解码的时候会去掉。将3个字节的二进制数据编码为4字节的文本，解码的时候会去掉。将3字节的二进制数据编码为4字节的文本，是可以让数据在邮件正文、网页等直接显示的。

# 说下 vue-router 中的导航钩子函数

# 说一下React setState原理

# 说说你所理解的中介者模式

# 你所理解的前端路由是什么

# SSL 连接断开后如何恢复

一共有两种方法来恢复断开的 SSL 连接，一种是使用 session ID，一种是 session ticket。

使用 session ID 的方式，每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。

目前所有的浏览器都支持这一种方法。但是这种方法有一个缺点是，session ID 只能够存在一台服务器上，如果我们的请求通过负载平衡被转移到了其他的服务器上，那么就无法恢复对话。

另一种方式是 session ticket 的方式，session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。

这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。

# 说一下ajax/axios/fetch三者的区别

# 微服务有什么好处

# Reflect 对象创建目的是什么

# require模式引入的查找方式是什么

# addEventListener再removeListener会不会造成内存泄露

# CDN 访问过程是什么

1.用户输入访问的域名,操作系统向 LocalDns 查询域名的 ip 地址.

2.LocalDns 向 ROOT DNS 查询域名的授权服务器(这里假设 LocalDns 缓存过期)

3.ROOT DNS 将域名授权 dns 记录回应给 LocalDns

4.LocalDns 得到域名的授权 dns 记录后,继续向域名授权 dns 查询域名的 ip 地址

5.域名授权 dns 查询域名记录后(一般是 CNAME )，回应给 LocalDns

6.LocalDns 得到域名记录后,向智能调度 DNS 查询域名的 ip 地址

7.智能调度 DNS 根据一定的算法和策略(比如静态拓扑，容量等),将最适合的 CDN 节点 ip 地址回应给 LocalDns

8.LocalDns 将得到的域名 ip 地址，回应给 用户端

9.用户得到域名 ip 地址后，访问站点服务器

10.CDN 节点服务器应答请求，将内容返回给客户端.(缓存服务器一方面在本地进行保存，以备以后使用，二方面把获取的数据返回给客户端，完成数据服务过程)

# node性能如何监控

node应用监控主要分两大类：业务逻辑型的监控和硬件方面的监控。

性能监控：

- 日志监控 可以通过监控异常日志的变动，将新增的异常类型和数量反映出来 监控日志可以实现pv和uv的监控，通过pv/uv的监控，可以知道使用者们的使用习惯，预知访问高峰

- 响应时间 响应时间也是一个需要监控的点。一旦系统的某个子系统出现异常或者性能瓶颈将会导致系统的响应时间变长。响应时间可以在nginx一类的反向代理上监控，也可以通过应用自己产生访问日志来监控

- 进程监控 监控日志和响应时间都能较好地监控到系统的状态，但是它们的前提是系统是运行状态的，所以监控进程是比前两者更为紧要的任务。监控进程一般是检查操作系统中运行的应用进程数，比如对于采用多进程架构的web应用，就需要检查工作进程的数，如果低于低估值，就应当发出警报

- 磁盘监控 磁盘监控主要是监控磁盘的用量。由于写日志频繁的缘故，磁盘空间渐渐被用光。一旦磁盘不够用将会引发系统的各种问题，给磁盘的使用量设置一个上限，一旦磁盘用量超过警戒值，服务器的管理者应该整理日志或者清理磁盘

- 内存监控 对于node而言，一旦出现内存泄漏，不是那么容易排查的。监控服务器的内存使用情况。如果内存只升不降，那么铁定存在内存泄漏问题。符合正常的内存使用应该是有升有降，在访问量大的时候上升，在访问量回落的时候，占用量也随之回落。监控内存异常时间也是防止系统出现异常的好方法。如果突然出现内存异常，也能够追踪到近期的哪些代码改动导致的问题

- cpu占用监控 服务器的cpu占用监控也是必不可少的项，cpu的使用分为用户态、内核态、IOWait等。如果用户态cpu使用率较高，说明服务器上的应用需要大量的cpu开销；如果内核态cpu使用率较高，说明服务器需要花费大量时间进行进程调度或者系统调用；IOWait使用率反映的是cpu等待磁盘I/O操作；cpu的使用率中，用户态小于70%，内核态小于35%且整体小于70%，处于正常范围。监控cpu占用情况，可以帮助分析应用程序在实际业务中的状况。合理设置监控阈值能够很好地预警

- cpu load监控 cpu load又称cpu平均负载。它用来描述操作系统当前的繁忙程度，又简单地理解为cpu在单位时间内正在使用和等待使用cpu的平均任务数。它有3个指标，即1分钟的平均负载、5分钟的平均负载，15分钟的平均负载。cpu load过高说明进程数量过多，这在node中可能体现在用于进程模块反复启动新的进程。监控该值可以防止意外发生

- I/O负载 I/O负载指的主要是磁盘I/O。反应的是磁盘上的读写情况，对于node编写的应用，主要是面向网络业务，是不太可能出现I/O负载过高的情况，大多数的I/O压力来自于数据库。不管node进程是否与数据库或其他I/O密集的应用共同处理相同的服务器，我们都应该监控该值防止意外情况

- 网络监控 虽然网络流量监控的优先级没有上述项目那么高，但还是需要对流量进行监控并设置流量上限值。即便应用突然受到用户的青睐，流量暴涨的时候也可以通过数值感知到网站的宣传是否有效。一旦流量超过警戒值，开发者就应当找出流量增长的原因。对于正常增长，应当评估是否该增加硬件设备来为更多用户提供服务。网络流量监控的两个主要指标是流入流量和流出流量

- 应用状态监控 除了这些硬性需要检测的指标之外，应用还应该提供一种机制来反馈其自身的状态信息，外部监控将会持续性地调用应用地反馈接口来检查它地健康状态

- dns监控 dns是网络应用的基础，在实际的对外服务产品中，多数都对域名有依赖。dns故障导致产品出现大面积影响的事件并不少见。由于dns服务通常是稳定的，容易让人忽略，但是一旦出现故障，就可能是史无前例的故障。对于产品的稳定性，域名dns状态也需要加入监控

# 为什么useState要使用数组而不是对象

useState运用了JS的解构思想。对象和数组的解构赋值区别是：

- 数组元素是有顺序的，数组解构时变量的取值由数组元素的位置决定，变量名可以任意命名

- 对象的属性是没有顺序的，解构时变量必需与属性同名才能取到正确的值

由此可以看出，数组会更加灵活，可以任意命名state和修改state的方法名。而useState内部原理是把state声明成一个数组，需要顺序一一对应。由于一个组件可以使用多个useState，为了避免冲突并确保state的准确性，useState要使用数组而不是对象。

# Node 更适合处理 I/O 密集型任务还是 CPU 密集型任务,为什么？

Node 更适合处理 I/O 密集型的任务。因为 Node 的 I/O 密集型任务可以异步调用，利用事件循环的处理能力，资源占用极少，并且事件循环能力避开了多线程的调用，在调用方面是单线程，内部处理其实是多线程的。

由于 Javascript 是单线程的原因，Node 不适合处理 CPU 密集型的任务，CPU 密集型的任务会导致 CPU 时间片不能释放，使得后续 I/O 无法发起，从而造成阻塞。但是可以利用到多进程的特点完成对一些 CPU 密集型任务的处理，不过由于 Javascript 并不支持多线程，所以在这方面的处理能力会弱于其他多线程语言（例如 Java、Go）。

# 什么是微服务

所谓的微服务是SOA架构下的最终产物，该架构的设计目标是为了肢解业务，使得服务能够独立运行

微服务可以按照业务划分，将一组特定的业务划分成一个服务，每个服务都有自己对的数据库，独立部署，服务直接通过Rest API进行通讯。每一个独立运行的服务组成整合系统

总结下，微服务是，由单一应用程序构成的小服务，拥有自己的进程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用HTTP api通讯。同时，服务会使用最小的规模的集中管理(例如docker)技术，服务可以用不同的编程语言与数据库等。微服务架构是将复杂臃肿的单体应用进行细粒度的服务化拆分，每个拆分出来的服务各自独立打包部署，并交由小团队进行开发和运维，从而极大地提高了应用交付地效率

微服务设计的原则： 各司其职 服务高于可用性和可扩展性

# vue双向数据绑定原理

# 说一下你理解的CORS

# 什么是 CDN 服务

CDN 是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域、不同运营商的服务器，向用户提供资源就近访问的功能。也就是说，用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，由 CDN 服务器将请求定位到最近的含有该资源的服务器上去请求。这样有利于提高网站的访问速度，同时通过这种方式也减轻了源服务器的访问压力。

# 实现单点登录的原理

# 介绍下你所理解的React设计思路,它的理念是什么

# node性能如何优化

# 微服务和单体应用的区别

# 神奇的null

```
// 请输出结果并进行解释
console.log([typeof null, null instanceof Object])
```

答案为：["object", false]

在MDN关于 null 的文档中也特别指出来了，typeof null 的结果是 "object"，它是ECMAScript的bug，其实应该是 "null"。但这个bug由来已久，在JavaScript中已经存在了将近二十年，也许永远不会修复，因为这牵扯到太多的Web系统，修复它会产生更多的bug，令许多系统无法正常工作。而 instanceof 运算符是用来测试一个对象在其原型链构造函数上是否具有 prototype 属性，null 值并不是以 Object 原型建出来的，所以 null instanceof Object 返回 false。

# 优先级顺序  
```
请输出结果并进行解释
var val = 'smtg';
console.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing');
```

答案是："Something"，因为 + 的优先级比条件运算符 condition ? val1 : val2 的优先级高。

# jsonp的工作原理

jsonp是一种跨域通信的手段，原理是通过script标签的src属性来实现跨域。实现机制如下：

1. 与服务端约定好一个回调函数名称，在客户端定义好这个函数，在请求url中添加callback=函数名的查询字符

2. 服务端接收到请求之后，将函数名和需要返回的数据，拼接成函数名(data)函数执行的形式返回

3. 页面接收到数据后，解析完成直接执行这个回调函数，这个时候数据就成功传输了客户端

# Redux 中间件是如何拿到store和action

redux中间件本质就是一个柯里化函数。

- redux applyMiddleware api源码，每个applyMiddleware接收2个参数，store的getState函数和dispatch函数，分别获得store和action，最终返回一个函数

- 该函数会被传入next的下一个middleware的dispatch方法，并返回一个接收action的新函数，这个函数可以直接调用next(action)，或者在其他需要的时刻去调用，或者不去调用

- 调用链中最后一个middleware会接收store的dispatch方法作为next参数，并且借此结束调用链

所以，middleware的函数时({getState,dispatch}) => next => action

# 介绍你所理解的组合模式

定义：组合模式（Composite Pattern），又叫“部分-整体”模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。

优点：
- 高层模块调用简单
- 节点自由增加

缺点：
- 在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。

# 了解函数式编程中的compose么

将多个函数的能力合并，创造一个新的函数。compose函数可以接受任意的参数，所有的参数都是函数，且执行方向是自右向左的，初始函数一定放到参数的最右面。

```
const compose=(...fns)=>(...args)=>{
  const [...tmpFns]=fns;
  const composed=(...restArgs)=>{
    if(tmpFns.length===0){
      return restArgs[0];
    }
    return composed(tmpFns.pop()(...restArgs));
  };
  return composed(...args);
};
```

# 对称加密和非对称加密的区别和用处

对称加密：对称加密采用了对称密码编码的技术，它的特点是文件加密和解密使用相同的密钥加密，也就是密钥也可以用作解密密钥，这种方法在密码学中叫做对称加密算法，对称加密算法使用起来简单快捷，密钥较短且破译困难，除了数据加密标准(DES),另一个对称密钥加密系统是国际数据加密算法(IDEA),它比DES的加密性好，而且对计算机功能要求也没有那么高。

- 对称加密：收发双方规定密钥
- 加密的人也能解密，这就是对称

问题：密钥需要传递，传递的过程中，可能被窃听和纂改

非对称加密: 与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥和私有密钥。公开密钥和私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫做非对称加密算法

非对称加密算法实现机密信息交换的基本过程是:甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开;得到该公用密钥的乙方使用该密钥对机密信息进行加密后在发送给甲方;甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。甲方只能用其专用密钥解密由其公用密钥加密后的任何信息

非对称加密的典型应用是数字签名。常见的非对称加密算法有：RSA,ECC(移动设备使用),Diffie-Hellman,EIGamal,DSA(数字签名使用)

- 发送人留着钥匙，把带锁的盒子传过去，加密的人锁上，但是解不开，就是非对称

问题：可能被窃听更换掉盒子（认证机构来给盒子做签名，也就是我们HTTPS需要的网站证书）

区别：

- 对称加密只需要一把密钥，非对称加密需要一对密钥(公钥和密钥)

- 对称加密 算法简单，加密解密容易，效率高，执行快；只有一把钥匙，密文如果被拦截，且密钥也被劫持，那么，信息很容易被破译，安全性能低；非对称加密算法及其复杂，安全性依赖算法与密钥，而且加密和解密效率很低；即使密文被拦截、公钥被获取，但是无法获取到私钥，也就无法破译密文，安全性能高

所以，非对称可靠但是慢，对称高效但不可靠，若配合使用，非对称加密进行身份验证和密钥交换，对称加密进行数据的加密，可达到最好的效果。

# Vue是如何收集依赖的

# 介绍你所理解的迭代器模式

# JS为什么要区分微任务和宏任务

# 讲一下你所了解的函数式编程

# 介绍你所理解的单例模式

定义：

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

主要解决：一个全局使用的类频繁地创建与销毁。

优点：
- 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
- 避免对资源的多重占用（比如写文件操作）。
- 
缺点：
- 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化

# Vue-cli默认是单页面的，如果要开发多页面应该怎么办

# js异步解决方案有哪几种
回调函数（callback）

- 优点：逻辑简单
- 缺点：深层级产生回调地狱

Promise

- 优点：一旦状态改变就不会在变，任何时候都可以得到这个结果;可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数
- 缺点：无法取消，当处于pengding状态时，无法得知目前进展到哪一个阶段

Generator

- 优点：执行可控；每一步可以传递数据，也可以传递异常
- 缺点：控制流程比较复杂，成本比较高

async/await

- 优点：代码清晰，不许需要链式调用就可以处理回调地狱的问题；错误的话可以被try catch
- 缺点：控制流程复杂，成本较高

此外，还可以通过事件监听、发布/订阅等方式解决异步问题。

# 介绍class和ES5的类以及区别
ES5的类：function

class：类声明创建一个基于原型继承的具有给定名称的新类

区别：
- 类声明不可以提升
- 类声明不允许再次声明已经存在的类，否则将会抛出一个类型错误
- class内部是严格模式，构造函数是可选的
- class的静态方法或者原型方法都不可枚举，并且这些方法都没有原型，不可被new
- class必须使用new 来调用
- class内部无法重写类名

# 说说Vue开发如何针对搜索引擎做SEO优化

虽然SPA单页面应用对SEO不友好，但是也有相应的解决方案。如果构建大型网站，比如商城类，直接上SSR服务器渲染；如果是个人博客、公司官网这类，其余三种都可以；如果对已用SPA开发完成的项目进行SEO优化，而且支持node服务器，请使用Phantomjs。

- SSR服务器渲染
Vue.js是构建客户端应用程序的框架。默认的情况下，可以在浏览器中输出Vue组件，进行生成DOM和操作DOM。然而，也可以将同一个组件渲染为服务器端的html字符串，将它们直接发送到浏览器，最后将这些静态标记为"激活"为客户端上完全可交互的应用程序。服务器渲染的 Vue.js 应用程序也可以被认为是"同构"或"通用"，因为应用程序的大部分代码都可以在服务器和客户端上运行。
```
权衡的地方：

    开发条件所限，浏览器特定的代码，只能在某些生命周期钩子函数中使用；一些外部扩展库可能需要特殊处理，才能在服务器渲染应用程序中运行
    
    环境和部署要求更高，需要node.js server 运行环境
    
    高流量的情况下，需要准备相应的服务器负载，并明智地采取缓存策略
    

优势:

    更好的seo，因为搜索引擎爬虫抓取工具可以直接查看完全渲染的页面
    
    更快的内容到达时间，特别是对于缓慢的网络情况或运行缓慢的设备
    

不足：

    一套代码两套执行环境，会引发各种问题，比如服务端没有window、document对象，处理方式是增加判断，如果是客户端才可以执行
    
    涉及构建设置和部署的更多要求，需要处于node server的运行环境
    
    更多的服务端负载
```

- Nuxt 静态化
Nuxt是一个基于Vue生态的更高层的框架，为开发服务端渲染的Vue应用提供了极其便利的开发体验。更酷的是：可以用它来作为静态站生成器。
静态化是Nuxt.js打包的另一种方式，算是Nuxt.js的一个创新点，页面加载速度很快，需要注意的是:在Nuxt.js执行generate静态化打包时，动态路由会被忽略。
```
优势:

    纯静态文件，访问速度超快
    
    对比SSR，不涉及到服务器负载方面问题
    
    静态网页不宜遭到黑客攻击，安全性更高
    
不足：

    如果动态路由参数多的话不适用
```

- 预渲染 prerender-spa-plugin
如果你只是用来改善少数营销页面(例如/，/about/，/contact等)的seo，那么你可能需要预渲染。无需使用web服务器实时动态编译html，而是使用预渲染的方式，在构建时简单地生成针对特定路由地静态HTML文件。优点就是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。
```
优势：

    改动小，引入插件配置即可
    
不足： 

    无法使用动态路由
    
    只适用少量页面的项目，页面多达几百个的情况下打包会非常慢
```

- 使用Phantomjs针对爬虫做处理
Phantomjs 是基于一个 webkit内核的无头浏览器，即没有UI界面，即它就是一个浏览器，只是其内的点击、翻页等为人相关操作需要程序设计实现。虽然"Phantomjs 宣布终止开发"，但是已经满足对Vue的SEO处理。
这种解决方案其实是一种旁路机制，原理就是通过 nginx 配置，判断访问的来源 UA 是否爬虫访问，如果是则就将搜索引擎的爬虫请求转发到一个 node server，在通过Phantomjs 来解析完整的html，返回给爬虫。 
```
优势：

    完全不用改动项目代码，按照原本的spa开发即可，对比开发SSR成本小不要太多
    
    对已用SPA开发完成的项目，这是最好的选择
    
不足：

    部署需要node服务器支持
    
    爬虫访问比网页访问要慢一些，因为定时要定时资源加载完成才返回给爬虫
    
    如果被恶意模拟百度爬虫大量循环爬取，会造成服务器负载方面问题，解决方法是判断访问的ip，是否是百度官方爬虫的ip
```

# 介绍你所理解的工厂模式

# Promise.reslove(obj),obj有几种形式

# 说说ES6对Object类型做了哪些优化更新

# 介绍你所理解的装饰器模式

# 虚拟列表是什么？说一下它的实现原理

# 说一下 JavaScript 的宿主对象和原生对象的区别

# 浏览器都有哪些进程，渲染进程中都有什么线程

# 什么是跨域?都有哪些方式会造成跨域，常见的解决跨域的方式有哪些

跨域指的是非同源的资源之间尝试着进行交互通信，而由于受浏览器同源策略的限制，无法正常进行交互通信。 浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JS实施的安全限制。无法跨域是浏览器对于用户安全的考虑，同源策略限制了以下行为：Cookie、LocalStorage和IndexDB 无法读取DOM和JS对象无法获取，ajax请求发送不出去。

非同源请求、服务端设置cors限制会造成跨域。

常见解决跨域的方式

- 利用jsonp进行跨域。是最常见的跨域方式之一。

- window.name+iframe window.name通过在iframe（一般动态创建）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window.name。然后，请求者可以检索window.name值作为响应。

- window.postMessage() HTML5新特性，可以用来向其他所有的 window 对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送 MessageEvent，如果在函数执行的过程中调用了它，就会让后面的函数超时无法执行。

- WebSocket WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很棒的实现。

- 图片ping或script标签跨域 图片ping常用于跟踪用户点击页面或动态广告曝光次数。script标签可以得到从其他来源数据，这也是JSONP依赖的根据。缺点：只能发送Get请求 ，无法访问服务器的响应文本（单向请求）


# 请问如何进行首页加载优化

- CDN分发: 通过在多台服务器部署相同的副本，当用户访问时，服务器根据用户跟哪台服务器地理距离小或者哪台服务器此时的压力小，来决定哪台服务器去响应这个请求

- 后端在业务层的缓存:数据库查询缓存是可以设置缓存的，这个对处于高频率的请求是很有用。值得注意的是，接口也是可以设置缓存的，比如获取一定时间内不会变的资源，设置缓存会很有用

- 静态文件缓存方案: 现在流行的方式是文件hash+强缓存的一个方案。比如hash+cache control:max-age=1年

- 前端的资源动态加载:

1. 路由动态加载，是最常用的方法，以页面为单位，进行动态加载
 
2. 组件动态加载，对于不在当前视窗的组件，先不加载
 
3. 图片懒加载，越来越多的浏览器支持原生的懒加载，通过给img标签加上 loading="lazy"来开启懒加载模式

利用好async和defer这两个属性: 如果是独立功能的js文件，可以加入async属性。如果是优先级低并且没有依赖的js，我们可以加入defer属性。

- 渲染的优先级: 浏览器有一套资源的加载优先级策略。也可以通过js来自己控制请求的顺序和渲染的顺序。一般我们不需要这么细粒度的控制，而且控制的代码也不好写。

- 前端做一些接口缓存:前端也可以做接口缓存，缓存的位置有两个，一个是内存，即保存给变量，另一个是localStorage。比如用户的签到日历(展示用户是否签到)，我们可以缓存这样的接口到localStorage，有效期是当天。或者有个列表页面，我们总是缓存上次的列表内容到本地，下次加载时，我们先从本地读取缓存，并同时发起请求到服务器获取最新列表

- 页面使用骨架屏: 在首屏加载完成之前，通过渲染一些简单元素进行占位。骨架屏虽然不能提高首屏加载速度，但可以减少用户在首屏等待的急躁心情

- 引入http2.0： http2对比http1.1，最主要的提升是运输性能，特别在接口小而多的时候

- 利用好http压缩:使用http压缩的效果会非常明显

# 介绍下浏览器事件流向

DOM2级事件规定的事件流包括三个阶段：事件捕获阶段，处于目标阶段，事件冒泡阶段。

事件捕获阶段（Event Capturing）： 事件捕获的用意是在于事件到达预定目标之前捕获它。因此，事件捕获的过程是让不太具体的节点先更早接收到事件，而最具体的节点应该最后接收到事件。

冒泡阶段（Event Bubbling）： 事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点，即document对象。

DOM2 与 DOM0区别：

DOM2级事件定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener，removeEventListener

# 说一下 Vue3 的 Composition API

# cdn分布式部署，如何处理用户请求最近的资源

# 说一下 let、const 的实现，使用 ES5 模拟实现

# 介绍冒泡排序、选择排序，说说冒泡排序如何优化

# 前端怎样做单元检测

# 301、302、304 的区别

# 什么是同源策略

# Vue-router history 模式部署的时候要注意什么?server 端用 nginx 和 node 时候分别怎么处理?

# 说一下递归和迭代的区别是什么，各有什么优缺点?

# 说一下对vue3.0的了解，vue3.0为什么要用代理?

# 手写一个观察者模式

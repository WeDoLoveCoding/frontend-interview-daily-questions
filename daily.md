# vue的双向绑定的原理是什么？

# Loader和Plugin的区别是什么？

# 请解释React中props和state的区别？

# 浏览器的本地存储(1)的cookie了解多少？

# 浏览器的本地存储(2)的WebStorage了解多少？

# 说一下vue-router的原理是什么?

# 防抖节流原理、区别以及应用，请用js实现。

# 在css中link和@import的区别是什么？

# 常见的loader以及作用的总结

# vue计算属性和普通属性的区别是什么?

# webpack中source map是什么？生产环境怎么用？

# 浏览器缓存机制(1)对于开发很重要，强缓存的内容能了解多少呢？

# 介绍js全部数据类型，基本数据类型和引用数据类型的区别

# react-router里的Link标签和a标签有什么区别？

# 说一说XSS攻击

# 谈谈你对重绘和回流的理解

# 简单说下你理解的语义化，怎样来保证你写的符合语义化？HTML5语义化标签了解下

# 常见的plugin以及作用的总结

# 说一下关于tree-shaking的原理

# 如何实现 webpack 持久化缓存

# webpack的构建流程是什么

# 说一说CSRF攻击

# CSS伪类和伪元素区别

# Vuex和localStorage的区别

# 说一下事件循环机制(node 浏览器)

# webpack的构建流程是什么

# Import和CommonJs在webpack打包过程中有什么不同

# dev-server是怎么跑起来的

# 谈谈关于对webpack热更新的原理

# 浏览器缓存机制(3)对于开发很重要，缓存位置的内容能了解多少呢

# webpack打包时Hash码是怎样生成的？随机值存在一样的情况，如何避免？

# 如何加快页面渲染速度，都有哪些方式？(js方面)

# HTTP请求特征是什么

# react里组件通信有几种方式，分别怎样进行通信

# 说一下栈和堆的区别，垃圾回收时栈和堆的区别

# 布局都有什么方式，float和position有什么区别

# 用JS代码实现事件代理

# 对虚拟DOM的理解？虚拟DOM主要做了什么？虚拟DOM本身是什么？

# 移动端需要注意什么

# 响应式布局用到的技术有几种方式

# 词法作用域和this的区别

# 介绍React高阶组件，适用于什么场景？

# 说一下Vue的keep-alive是如何实现的，具体缓存的是什么

# 请描述下css盒模型基本概念

# React组件中怎么做事件代理？它的原理是什么？

# Promise 构造函数是同步还是异步执行，then呢？

# 说一下mobx和redux有什么区别

# CSS预处理器的概念

# shouldComponentUpdate是为了解决什么问题

# React里setState到底是异步还是同步

# react-redux的工作流程是什么

# 添加原生事件不移除为什么会内存泄漏，还有哪些地方会存在内存泄漏？（js）

# 怎么处理项目中的异常捕获行为

# 点击一个按钮，浏览器会做些什么事情【呈现效果时流程】

# 解决异步的问题的几种方式？Promise解决了异步问题吗？

# 与HTTP相关的协议有哪些？TCP/IP DNS URI/URL HTTPS

# CDN有哪些优化静态资源加载速度的机制

# 说说你理解的node 中间层怎样做的请求合并转发

# webpack做了什么？使用webpack构建是否有做一些自定义操作

# webpack如何用localStorage离线缓存静态资源

# 关于对 Vue 项目进行优化有哪些？

# 说一下React.Component和React.PureComponent的区别

# 使用import时，webpack对node_modules里的依赖会做什么

# Redux和Vuex有什么区别,说一下它们的共同思想

# 为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象

# 说一下mysql和mongodb的区别

# 说一下你对React context的理解

# webpack 里面的插件是如何实现的

# 使用TS的优势有哪些

# 直接给一个数组项赋值，Vue 能检测到变化吗

# Vue 组件间通信有哪几种方式

# 项目如何管理模块

# 在哪个生命周期内调用异步请求

# 说明一下JS封装的原理

# 说出常用的页面优化实现方案

# 回调函数和任务队列的区别

# 请你谈谈对无状态的理解 (React)

# 如何理解事件委托

# BFC是什么？触发BFC的条件是什么？有哪些应用场景

# 说一下单向数流有什么好处

# React怎么做数据检查和变化

# 类数组转化为数组

# 说一下关于tree-shaking的原理

# Vue 中的 key 有什么作用

# 说一下Vue 的父组件和子组件生命周期钩子函数执行顺序

# 使用过 Vue SSR 吗？说说 SSR

# 什么情况下出现浏览器分层？(css部分)

# 说下JS继承的原理

# 说一下Vue的$nextTick原理

# 说一下Vue单页与多页的区别

# v-model是如何实现的，语法糖实际是什么

# 怎样理解 Vue 的单向数据流

# React SSR实现过程

# React SSR实现原理是什么,需要注意什么事项

# 子组件可以直接改变父组件的数据么？说说你的理由？(vue)

# 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗

# 实现数组去重

# 描述下JS中Prototype的概念

# 实现数组扁平化

# React事件绑定原理是什么

# 为什么不建议使用通配符初始化css样式

# 说一下koa2和express区别

# link 标签定义

# 渲染过程中遇到JS文件怎么处理?(浏览器解析过程)

# Object.is()与原来的比较操作符 "===" 、"==" 的区别

使用双等号进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较

使用三等号进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false

使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 认定为是相等的。

# 三种事件模型是什么

1、DOM0级事件模型（原始事件模型）

通过属性绑定，如 onclick="xxxx()"，或者通过获取到元素后，以赋值的形式绑定事件

2、DOM2级事件模型

新增了捕获和冒泡机制，并支持同一个元素绑定多个事件。

DOM2 级事件模型共有三个阶段：

事件捕获阶段：事件从 document 向下传播到目标元素，依次检查所有节点是否绑定了监听事件，如果有则执行。

事件处理阶段：事件在达到目标元素时，触发监听事件。

事件冒泡阶段：事件从目标元素冒泡到 document，并且一次检查各个节点是否绑定了监听函数，如果有则执行。

3、IE事件模型

IE事件只支持冒泡，所以事件流有两个阶段：

事件处理阶段：事件在达到目标元素时，触发监听事件。

事件冒泡阶段：事件从目标元素冒泡到 document，并且一次检查各个节点是否绑定了监听函数，如果有则执行。


# DOCTYPE 的作用是什么

# iframe有哪些缺点

# 说说你对浏览器的理解

# 谈谈你对ajax的理解

# 简单介绍使用图片base64编码的优点和缺点

# 请说出目前主流的js模块化实现的技术有哪些?他们的区别在哪儿

# for..in和Object.keys的区别
for..in
- 遍历对象上及其原型链上可枚举的属性
- 如果用于遍历数组，除了遍历其元素外，还会遍历开发者对数组对象自定义的可枚举属性及其原型链上的可枚举属性（不推荐for...in遍历数组)
- 遍历对象返回的属性名和遍历数组返回的索引都是字符串类型
- 某些情况下，可能按随机顺序遍历数组元素

Object.keys
- 返回对象自身可枚举属性组成的数组
- 不会遍历对象原型链上的属性以及Symbol属性
- 对数组的遍历循序和for..in一致

for of
- es6中添加的循环遍历语法
- 支持遍历数组，类数组对象(DOM NodeList)，字符串，Map对象，Set对象
- 不支持遍历普通对象
- 遍历后输出的结果为数组元素的值
- 可搭配实例方法entries(),同时输出数组的内容和索引

# 哪些操作会造成内存泄漏

# 什么是浏览器的同源策略

# 说一下你理解margin重叠的问题

# 网页验证码是干嘛的，是为了解决什么安全问题

# display、position和float的相互关系

# 前端需要注意哪些SEO

SEO具体是指通过网站结构调整、网站内容建设、网站代码优化、以及站外优化（网站站外推广、网站品牌建设等），使网站满足搜索引擎的收录排名需求，提高网站在搜索引擎中关键字的排名，从而吸引精准用户进入网站，获得免费流量，产生直接销售或品牌推广。

需要注意：

1、 合理的title，description，keyswords 搜索引擎对这三项的权重逐个减小，title 值强调重点即可，重要的关键

词出现不要超过两次，而且要靠前。

2 、不同页面的tilte要有所不同；description把页面的内容高度概括，长度合适，不可过分堆叠关键词，不同页面

description有所不同。keyswords列举出重要的关键词即可。

3、语义化的HTML代码，符合W3C 规范：语义化代码有利于搜索引擎理解网页。

4 、重要的内容HTML代码放在前面：搜索引擎抓取HTML 的顺序是从上到下，有的搜索引擎对抓取长度有限制，保

证重要内容一定会被抓取。

5 、重要的内容不要用js输出，爬虫不会执行js获取内容。

6 、尽量少用iframe ，搜索引擎不会抓取iframe中的内容。

7 、非装饰的图片必须加alt 。

8 、提高网站速度：网站速度是搜索引擎排序的一个重要指标。

# 简单说一下V8引擎的垃圾回收机制

# 谈谈对JSON的理解

# 渲染页面时常见的不良现象有哪些?(浏览器渲染过程)
白屏、闪烁

# html布局元素的分类有哪些? 描述下每种布局元素的应用场景

# componentWillReceiveProps的触发条件是什么

# javascript 代码中的"use strict"是什么意思?为什么使用它 

# javascript 代码中的"use strict"是什么意思?为什么使用它

# 什么是 polyfill

# 说一下Vue的生命周期以及每个阶段做的事情
1.beforeCreate(创建前) 在数据观测和初始化事件还没有开始

2.created(创建后) 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来

3.beforeMounted(挂载前) 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成下面的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上

4.mounted(挂载后) 在el被新创建的vm.$el替换，并挂载到实例上去之后调用。实例已经完成下面的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中，此过程中可进行ajax交互

5.beforeUpdate(更新前) 在数据更新之前调用，发生在虚拟dom重新渲染和打补丁之前。可以在该钩子中进一步更改状态，不会触发重复渲染过程

6.update(更新后) 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件dom已经更新，所以可以执行依赖于dom操作。但是在大多数情况下，在此期间避免更改状态，因为这可能会导致更新无法循环。此钩子在服务端渲染期间不被调用

7.beforeDestroy(销毁前) 在实例销毁之前调用。实例仍然完全可以用。

8.destroyed(销毁后) 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。此钩子在服务端渲染期间不被调用

# 你所理解的同步和异步的区别是什么

# javascript 创建对象的几种方式

# 说一下你所理解JavaScript中的作用域与变量声明提升

# 内部属性[[Class]]是什么

# 检测浏览器版本版本有哪些方式

# React 高阶组件、Render props和hooks有什么区别,为什么不断迭代

# 说一下Vue template到render的过程

# 如何解决跨域问题

- 将 document.domain 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe的话，我们也可以对这个 iframe 进行操作。如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的iframe 进行通信的问题，我们可以使用 location.hash 或者 window.name 或者postMessage 来解决问题

- 使用 location.hash 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。

- 使用 window.name 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，这种方式的好处是可以传输的数据量大。

- 使用 postMessage 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。

- 使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script 标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get请求。

- 使用 CORS 的方式，CORS 是一个 W3C 标准，全称是"跨域资源共享"。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。

- 使用 websocket 协议，这个协议没有同源限制。

- 使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。

# margin和padding分别适合什么场景使用

# CSS多列等高如何实现

# 如何处理HTML5新标签的浏览器兼容问题

# 介绍一下你对浏览器内核的理解

# 扫描二维码登录网页是什么原理，前后两个事件是如何联系的

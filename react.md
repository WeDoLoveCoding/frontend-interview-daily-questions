# React 面试题

## 你知道的React性能优化有哪些方法？

## 你对immutable有了解吗？它有什么作用？
1、Immutable实现的原理

Immutable实现的原理是利用结构共享形成持久化数据结构，也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable使用了结构共享，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。

2、Immutable的优点

（1）节约内存

JavaScript 中的对象一般是可变的（Mutable），因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。为了解决这个问题，一般的做法是使用shallowCopy（浅拷贝）或 deepCopy（深拷贝）来避免被修改，但这样做造成了CPU和内存的浪费。Immutable 可以很好地解决这些问题。

（2）Undo/Redo，Copy/Paste，时间轴等功能容易实现

因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能。

（3）并发安全

Immutable Data一旦创建，就不能再被更改,也就不需要并发锁。

3、Immutable使用

（1）与React搭配使用，Immutable简洁高效的判断数据是否变化，提高渲染速度及性能

（2）与Redux/flux搭配使用

## 在React中创建动画有哪些方式
创建React动画有以下几种：

1.基于定时器或requestAnimationFrame的间隔动画；使用定时器可能会有掉帧问题，而使用requestAnimationFrame则性能较好，完全使用js，不依赖css，帧数跟屏幕刷新率一致，页面运行到后台会自动暂停提高性能。

2.基于css3中的animation和transition简单动画；有较高的性能，代码量少，但是只能依赖于css效果，对于复杂动画比较难实现跟控制。

3.React动画插件CssTransitionGroup；性能比较好，但限定于入场跟出场场景。

4.其他第三方动画库。

## React为什么要搞Hooks，React Hooks帮我们解决了哪些问题
React Hooks是React 16.8的新增特性。它可以让你在不编写class的情况下使用state及其他React的特性（如：可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React）。
Hooks是一种更简单的方式，用于封装用户界面中的有状态行为和副作用。

Hook 使用规则：
* 只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。
* 只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中）

React Hooks 出现之前，UI 组件我们可以使用函数，无状态组件来展示 UI，而对于容器组件，函数组件就显得无能为力，我们依赖于类组件来获取数据，处理数据，并向下传递参数给 UI 组件进行渲染,无状态函数，是通过函数来创建组件，这样的好处是它在创建时，只会保持一个实例，避免了不必要的内存分配和检查，我们应该使用无状态组件。但是它的问题在于它不存在state和生命周期。而Hook 的出现，解决了这个问题。

React Hooks相比于类组件有以下的好处:

* 代码可读性更强，原本同一块功能的代码逻辑被拆分在了不同的生命周期函数中，容易使开发者不利于维护和迭代，通过 React Hooks 可以将功能代码聚合，方便阅读维护
* 组件树层级变浅，在原本的代码中，我们经常使用 HOC/render props 等方式来复用组件的状态，增强功能等，无疑增加了组件树层数及渲染，而在 React Hooks 中，这些功能都可以通过强大的自定义的 Hooks 来实现

## 怎么实现React组件的国际化
国际化的主要原理：
通过改变语言状态来切换不同的语言配置文件（该文件可以是json或js文件），解析配置文件进行渲染。

一般多语言国际化这种全局需求，我们可以使用React的context来全局共享数据，包含："当前语言"和一些通用词汇语言包。

React组件本身也可以维护一套自己的语言包，例如时间选择器等，通过获取全局的"当前语言"，然后通过映射获取指定位置的字符，进行拼接或展示。

在应用过程中，注意以下几点:
* 切换语言是一个低频需求，但语言包可能会比较大，可以按需加载
* 限制词语或句子的长度，在语言切换时，长度可能发生变化。比如，英文单词可能比中文长，会影响布局
* 注意颜色在不同语言、文化中的差异
* 注意日期和货币格式在不同国家和地区的差异

## 什么是受控组件和非受控组件
受控组件和非受控组件是针对表单而言的。受控和非受控之间可互相转化。
* 受控组件
 1. 组件中表单的值（value、checked）受state的控制，需要显式设置value或checked属性。
 2. 需要给表单元素绑定onChange事件，value的值由setState来修改。
 
 使用场景：
 需要对组件的value值进行修改时，使用受控组件。
 
 如：表单的实时校验，添加相应的状态和提示
 
 * 非受控组件
 1. 在表现形式上，表单组件不设置value属性（单选、复选为checked属性）。
 2. 表单的数据由DOM处理，可通过ref获取DOM节点后再获取value的值。
 
 使用场景：
 任何时候都不需要修改value。

## 了解 redux 么，说一下 redux 吧
Redux 本身是个状态管理库,核心或者说目的一句话就能概括, 清晰的描述应用的状态。

Redux 核心和原则

* 这个应用的状态是一个唯一的状态树
* 状态是只读的, 只能通过 action 来触发修改, 其实实际修改状态的是 reducer
* 修改状态只能通过纯函数

Redux 中的概念

1.reducer

reducer 就是实际改变 state 的函数, 在 redux 中, 也只有 reducer 能够改变 state.
根据 redux 的原则, 整个应用只有一个唯一的状态树, 这样, 理论上只要一个 reducer 就够了. 但是, 实际编码时, 如果应用稍具规模, 只有一个 reducer 文件, 显然不利于分模块合作开发, 也不利于代码维护.
所以, reduer 一般是按模块, 或者根据你所使用的框架来组织, 会分散在多个文件夹中. 这时, 可以通过 redux 提供的 API combineReducers 来合并多个 reducer, 形成一个唯一的状态树.
reducer 的使用只要注意 2 点:

1、必须是纯函数2、多个 reducer 文件时, 确保每个 reducer 处理不同的 action, 否则可能会出现后面的 reducer 被覆盖的情况

2.state

state 或者说是 store, 其实就是整个应用的状态. 

3.action

redux 中的 action 其实就是一个 包含 type 字段的plain object. type 字段决定了要执行哪个 reducer, 其他字段作为 reducer 的

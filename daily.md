# vue的双向绑定的原理是什么？

# Loader和Plugin的区别是什么？

# 请解释React中props和state的区别？

# 浏览器的本地存储(1)的cookie了解多少？

# 浏览器的本地存储(2)的WebStorage了解多少？

# 说一下vue-router的原理是什么?

# 防抖节流原理、区别以及应用，请用js实现。

# 在css中link和@import的区别是什么？

# 常见的loader以及作用的总结

# vue计算属性和普通属性的区别是什么?

# webpack中source map是什么？生产环境怎么用？

# 浏览器缓存机制(1)对于开发很重要，强缓存的内容能了解多少呢？

# 介绍js全部数据类型，基本数据类型和引用数据类型的区别

# react-router里的Link标签和a标签有什么区别？

# 说一说XSS攻击

# 谈谈你对重绘和回流的理解

# 简单说下你理解的语义化，怎样来保证你写的符合语义化？HTML5语义化标签了解下

# 常见的plugin以及作用的总结

# 说一下关于tree-shaking的原理

# 如何实现 webpack 持久化缓存

# webpack的构建流程是什么

# 说一说CSRF攻击

# CSS伪类和伪元素区别

# Vuex和localStorage的区别

# 说一下事件循环机制(node 浏览器)

# webpack的构建流程是什么

# Import和CommonJs在webpack打包过程中有什么不同

# dev-server是怎么跑起来的

# 谈谈关于对webpack热更新的原理

# 浏览器缓存机制(3)对于开发很重要，缓存位置的内容能了解多少呢

# webpack打包时Hash码是怎样生成的？随机值存在一样的情况，如何避免？

# 如何加快页面渲染速度，都有哪些方式？(js方面)

# HTTP请求特征是什么

# react里组件通信有几种方式，分别怎样进行通信

# 说一下栈和堆的区别，垃圾回收时栈和堆的区别

# 布局都有什么方式，float和position有什么区别

# 用JS代码实现事件代理

# 对虚拟DOM的理解？虚拟DOM主要做了什么？虚拟DOM本身是什么？

# 移动端需要注意什么

# 响应式布局用到的技术有几种方式

# 词法作用域和this的区别

# 介绍React高阶组件，适用于什么场景？

# 说一下Vue的keep-alive是如何实现的，具体缓存的是什么

# 请描述下css盒模型基本概念

# React组件中怎么做事件代理？它的原理是什么？

# Promise 构造函数是同步还是异步执行，then呢？

# 说一下mobx和redux有什么区别

# CSS预处理器的概念

# shouldComponentUpdate是为了解决什么问题

# React里setState到底是异步还是同步

# react-redux的工作流程是什么

# 添加原生事件不移除为什么会内存泄漏，还有哪些地方会存在内存泄漏？（js）

# 怎么处理项目中的异常捕获行为

# 点击一个按钮，浏览器会做些什么事情【呈现效果时流程】

# 解决异步的问题的几种方式？Promise解决了异步问题吗？

# 与HTTP相关的协议有哪些？TCP/IP DNS URI/URL HTTPS

# CDN有哪些优化静态资源加载速度的机制

# 说说你理解的node 中间层怎样做的请求合并转发

# webpack做了什么？使用webpack构建是否有做一些自定义操作

# webpack如何用localStorage离线缓存静态资源

# 关于对 Vue 项目进行优化有哪些？

# 说一下React.Component和React.PureComponent的区别

# 使用import时，webpack对node_modules里的依赖会做什么

# Redux和Vuex有什么区别,说一下它们的共同思想

# 为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象

# 说一下mysql和mongodb的区别

# 说一下你对React context的理解

# webpack 里面的插件是如何实现的

# 使用TS的优势有哪些

# 直接给一个数组项赋值，Vue 能检测到变化吗

# Vue 组件间通信有哪几种方式

# 项目如何管理模块

# 在哪个生命周期内调用异步请求

# 说明一下JS封装的原理

# 说出常用的页面优化实现方案

# 回调函数和任务队列的区别

# 请你谈谈对无状态的理解 (React)

# 如何理解事件委托

# BFC是什么？触发BFC的条件是什么？有哪些应用场景

# 说一下单向数流有什么好处

# React怎么做数据检查和变化

# 类数组转化为数组

# 说一下关于tree-shaking的原理

# Vue 中的 key 有什么作用

# 说一下Vue 的父组件和子组件生命周期钩子函数执行顺序

# 使用过 Vue SSR 吗？说说 SSR

# 什么情况下出现浏览器分层？(css部分)

# 说下JS继承的原理

# 说一下Vue的$nextTick原理

# 说一下Vue单页与多页的区别

# v-model是如何实现的，语法糖实际是什么

# 怎样理解 Vue 的单向数据流

# React SSR实现过程

# React SSR实现原理是什么,需要注意什么事项

# 子组件可以直接改变父组件的数据么？说说你的理由？(vue)

# 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗

# 实现数组去重

# 描述下JS中Prototype的概念

# 实现数组扁平化

# React事件绑定原理是什么

# 为什么不建议使用通配符初始化css样式

# 说一下koa2和express区别

# link 标签定义

# 渲染过程中遇到JS文件怎么处理?(浏览器解析过程)

# Object.is()与原来的比较操作符 "===" 、"==" 的区别

使用双等号进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较

使用三等号进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false

使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 认定为是相等的。

# 三种事件模型是什么

1、DOM0级事件模型（原始事件模型）

通过属性绑定，如 onclick="xxxx()"，或者通过获取到元素后，以赋值的形式绑定事件

2、DOM2级事件模型

新增了捕获和冒泡机制，并支持同一个元素绑定多个事件。

DOM2 级事件模型共有三个阶段：

事件捕获阶段：事件从 document 向下传播到目标元素，依次检查所有节点是否绑定了监听事件，如果有则执行。

事件处理阶段：事件在达到目标元素时，触发监听事件。

事件冒泡阶段：事件从目标元素冒泡到 document，并且一次检查各个节点是否绑定了监听函数，如果有则执行。

3、IE事件模型

IE事件只支持冒泡，所以事件流有两个阶段：

事件处理阶段：事件在达到目标元素时，触发监听事件。

事件冒泡阶段：事件从目标元素冒泡到 document，并且一次检查各个节点是否绑定了监听函数，如果有则执行。


# DOCTYPE 的作用是什么

# iframe有哪些缺点

# 说说你对浏览器的理解

# 谈谈你对ajax的理解

# 简单介绍使用图片base64编码的优点和缺点

# 请说出目前主流的js模块化实现的技术有哪些?他们的区别在哪儿

# for..in和Object.keys的区别
for..in
- 遍历对象上及其原型链上可枚举的属性
- 如果用于遍历数组，除了遍历其元素外，还会遍历开发者对数组对象自定义的可枚举属性及其原型链上的可枚举属性（不推荐for...in遍历数组)
- 遍历对象返回的属性名和遍历数组返回的索引都是字符串类型
- 某些情况下，可能按随机顺序遍历数组元素

Object.keys
- 返回对象自身可枚举属性组成的数组
- 不会遍历对象原型链上的属性以及Symbol属性
- 对数组的遍历循序和for..in一致

for of
- es6中添加的循环遍历语法
- 支持遍历数组，类数组对象(DOM NodeList)，字符串，Map对象，Set对象
- 不支持遍历普通对象
- 遍历后输出的结果为数组元素的值
- 可搭配实例方法entries(),同时输出数组的内容和索引

# 哪些操作会造成内存泄漏

# 什么是浏览器的同源策略

# 说一下你理解margin重叠的问题

# 网页验证码是干嘛的，是为了解决什么安全问题

# display、position和float的相互关系

# 前端需要注意哪些SEO

SEO具体是指通过网站结构调整、网站内容建设、网站代码优化、以及站外优化（网站站外推广、网站品牌建设等），使网站满足搜索引擎的收录排名需求，提高网站在搜索引擎中关键字的排名，从而吸引精准用户进入网站，获得免费流量，产生直接销售或品牌推广。

需要注意：

1、 合理的title，description，keyswords 搜索引擎对这三项的权重逐个减小，title 值强调重点即可，重要的关键

词出现不要超过两次，而且要靠前。

2 、不同页面的tilte要有所不同；description把页面的内容高度概括，长度合适，不可过分堆叠关键词，不同页面

description有所不同。keyswords列举出重要的关键词即可。

3、语义化的HTML代码，符合W3C 规范：语义化代码有利于搜索引擎理解网页。

4 、重要的内容HTML代码放在前面：搜索引擎抓取HTML 的顺序是从上到下，有的搜索引擎对抓取长度有限制，保

证重要内容一定会被抓取。

5 、重要的内容不要用js输出，爬虫不会执行js获取内容。

6 、尽量少用iframe ，搜索引擎不会抓取iframe中的内容。

7 、非装饰的图片必须加alt 。

8 、提高网站速度：网站速度是搜索引擎排序的一个重要指标。

# 简单说一下V8引擎的垃圾回收机制

# 谈谈对JSON的理解

# 渲染页面时常见的不良现象有哪些?(浏览器渲染过程)
白屏、闪烁

# html布局元素的分类有哪些? 描述下每种布局元素的应用场景

# componentWillReceiveProps的触发条件是什么

# javascript 代码中的"use strict"是什么意思?为什么使用它 

# javascript 代码中的"use strict"是什么意思?为什么使用它

# 什么是 polyfill

# 说一下Vue的生命周期以及每个阶段做的事情
1.beforeCreate(创建前) 在数据观测和初始化事件还没有开始

2.created(创建后) 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来

3.beforeMounted(挂载前) 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成下面的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上

4.mounted(挂载后) 在el被新创建的vm.$el替换，并挂载到实例上去之后调用。实例已经完成下面的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中，此过程中可进行ajax交互

5.beforeUpdate(更新前) 在数据更新之前调用，发生在虚拟dom重新渲染和打补丁之前。可以在该钩子中进一步更改状态，不会触发重复渲染过程

6.update(更新后) 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件dom已经更新，所以可以执行依赖于dom操作。但是在大多数情况下，在此期间避免更改状态，因为这可能会导致更新无法循环。此钩子在服务端渲染期间不被调用

7.beforeDestroy(销毁前) 在实例销毁之前调用。实例仍然完全可以用。

8.destroyed(销毁后) 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。此钩子在服务端渲染期间不被调用

# 你所理解的同步和异步的区别是什么

# javascript 创建对象的几种方式

# 说一下你所理解JavaScript中的作用域与变量声明提升

# 内部属性[[Class]]是什么

# 检测浏览器版本版本有哪些方式

# React 高阶组件、Render props和hooks有什么区别,为什么不断迭代

# 说一下Vue template到render的过程

# 如何解决跨域问题

- 将 document.domain 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe的话，我们也可以对这个 iframe 进行操作。如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的iframe 进行通信的问题，我们可以使用 location.hash 或者 window.name 或者postMessage 来解决问题

- 使用 location.hash 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。

- 使用 window.name 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，这种方式的好处是可以传输的数据量大。

- 使用 postMessage 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。

- 使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script 标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get请求。

- 使用 CORS 的方式，CORS 是一个 W3C 标准，全称是"跨域资源共享"。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。

- 使用 websocket 协议，这个协议没有同源限制。

- 使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。

# margin和padding分别适合什么场景使用

# CSS多列等高如何实现

# 如何处理HTML5新标签的浏览器兼容问题

# 介绍一下你对浏览器内核的理解

# 扫描二维码登录网页是什么原理，前后两个事件是如何联系的

# 说一下你所理解的渲染原理

- 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。

- 然后对 CSS 进行解析，生成 CSSOM 规则树。

- 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。

- 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。

- 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。

# 如何判断一个对象是否属于某个类

- 第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置

- 第二种方式可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写

- 第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用Object.prototype.toString.call() 方法来打印对象的[[Class]] 属性来进行判断

# 什么是DOM和BOM

# CSS选择符有哪些
id 选择器（#myid）

类选择器（.myclassname）

标签选择器（div,h1,p）

后代选择器（h1 p）

相邻后代选择器（子）选择器（ul>li）

兄弟选择器（li~a）

相邻兄弟选择器（li+a）

属性选择器（a[rel="external"]）

伪类选择器（a:hover,li:nth-child）

伪元素选择器（::before、::after）

通配符选择器（*）

# 标准模式与兼容模式各有什么区别

# css如何影响文档解析

css加载不会阻塞DOM树的解析, 但会阻塞DOM树的渲染，也会阻塞后面js语句的执行。 因此，为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度，比如可以使用以下几种方法:

1、使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)

2、对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)

3、合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)

4、减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)

# 说一下你所了解的javascript的作用域链

# DOMContentLoaded事件和Load事件的区别

# Symbol 值的强制类型转换

# HTML5有哪些新特性、移除了哪些元素

HTML5新特性：

拖放（Drag and drop）API

语义化标签（header、nav、footer、section、article、aside）

音频、视频（audio、video）API

画布（canvas）API

地理定位（Geolocation）API

本地离线存储（localStorage），即长期存储数据，浏览器关闭后数据不丢失；会话存储（sessionStorage），即数据在浏览器关闭后自动删除

表单控件（calender、date、time、url、email、search）

新的技术（webworker、websocket）

新的文档属性 document.visibilityState


移除的元素：

纯表现的元素：basefont、big、center、font、s、strike、tt、u

对可用性产生负面影响的元素：frame、frameset、noframes

# 说一下对DTD的理解

DTD（ Document Type Definition 文档类型定义）是一组机器可读的规则，它们定义 XML或 HTML 的特定版本中所有允许元素及它们的属性和层次关系的定义。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。

DTD 是对 HTML 文档的声明，还会影响浏览器的渲染模式（工作模式）。主要用来解决传输问题，它的存在可以使我们能够使用某个标准的DTD来 交换数据、检验数据。

# 常见浏览器所用的内核

- IE 浏览器内核：Trident 内核，也是俗称的 IE 内核

- Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit内核，现在是 Blink 内核

- Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核

- Safari 浏览器内核：Webkit 内核

- Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit又到了 Blink 内核

- 360 浏览器、猎豹浏览器内核：IE + Chrome 双内核

- 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）

- 百度浏览器、世界之窗内核：IE 内核

- 2345 浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了

- UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核

# 什么是文档的预解析

# js继承的几种实现方式

# React key是干什么用的,为什么要加上key

key是React用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识

在开发过程中，我们需要保证某个元素的key在其同级元素中具有唯一性

在React Diff算法中React会借助元素的key值来判断该元素是新创建的还是被移动而来的元素，从而减少不必要的元素重新渲染

此外，React还需要借助Key值来判断元素与状态的关联关系

几点注意事项:
- key值一定要和具体的元素一一对应
- 尽量不要使用数组的index去作为key值
- 永远不要试图在render的时候用随机数或者其他操作给元素加上不稳定的key，这样会造成的性能开销比不加key的情况下要糟糕

# 说一下你理解的 HTTPS 中间人攻击

# 说一下你所理解的观察者模式

# SGML、HTML、XML和XHTML的区别

# 说一下你所了解的react-fiber

# 异步编程的实现方式是什么

1、回调函数

优点：简单、容易理解 缺点：不利于维护，代码耦合高，多个异步操作下容易形成回调地狱。

2、Promise

优点：可以利用then方法，进行链式写法；可以书写错误时的回调函数； 缺点：编写和理解，相对比较难，语义不是那么明确

3、Generation

优点：函数体内外的数据交换、错误处理机制 缺点：流程管理不方便，控制权的转换需要特别注意

4、async/await

优点：内置执行器、更好的语义、更广的适用性、返回的是Promise、结构清晰。 缺点：错误处理机制， 需要try-catch捕获

# 什么是函数柯里化

把接收多个参数的函数变换为接收一个单一参数（最初函数的第一个参数）的函数，并返回接收剩余参数而且返回结果的新函数的技术。

优点：

- 可以延迟计算，即如果调用柯里化函数传入参数是不调用的，会将参数添加到数组中存储，等到没有参数传入的时候进行调用

- 参数复用，当在多次调用同一个函数，并且传递的参数绝大多数是相同的，那么该函数可能是一个很好的柯里化函数

# 说一下import的原理，和require的不同之处

import原理(实际上就是ES6 module的原理)：简单来说就是闭包作用。

为了创建Module的内部作用域，会调用一个包装函数

包装函数的返回值也就是Module向外公开的API，也就是所有export出去的变量

import是拿到module导出变量的引用

与require的不同之处：

CommonJS模块输出的是一个值的拷贝，ES6模块输出的值的引用

CommonJS模块是运行时加载，ES6模块是编译时输出接口

CommonJS是运行时加载对应模块，一旦输出一个值，即使模块内部对其做出改变，也不影响输出值。而ES6模块不同，import导入是在JS引擎对脚步静态分析时确定，获取到的是一个只读引用。等脚本引擎运行时，会根据这个引用去对应模块中的取值，所以引用对应的值改变的时候，其导入的值也会发生改变
